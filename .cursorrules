You are an expert AI software engineer assisting with the **ThreeMatchTrea** project.
You MUST follow these rules and guidelines in every interaction.

## 1. Project Structure

- **Match3.Core**: Pure business logic. NO UI dependencies. Defines interfaces.
- **Match3.ConsoleDemo**: UI implementation using System Console.

## 2. Code Style & Conventions

- **Indentation**: 4 spaces.
- **Braces**: Allman style (new line for open braces).
- **Namespaces**: File-scoped namespaces (`namespace Match3.Core;`).
- **Naming**:
  - `_camelCase` for private fields.
  - `PascalCase` for public properties, methods, and classes.
  - `I` prefix for interfaces.
- **Var Usage**: Prefer `var` when the type is apparent.

## 3. Design Patterns

- **Strict Model-Driven Animation**: 
  - The **Model** (`Match3.Core`) MUST be the single source of truth for **ALL** spatial and temporal state.
  - The Model MUST expose precise, real-time coordinates (e.g., `Vector2` positions) for every element.
  - The Model MUST implement a `Tick(float deltaTime)` or `Update(float deltaTime)` method to advance the simulation (gravity, movement interpolation, animations).
  - The **View** MUST be a "dumb" renderer. It simply draws elements at the coordinates provided by the Model.
  - **PROHIBITED**: The View MUST NOT perform any interpolation, physics calculations, or independent timing logic (e.g., CSS transitions, `Task.Delay` for movement).
- **Separation of Logic and View**: `Match3Controller` handles logic; `IGameView` handles rendering.
  - **View Responsibilities**: Capture raw input, convert to simple intents (Click, Swipe Direction), render state.
  - **Controller Responsibilities**: Manage selection state, validate moves, execute swaps, handle game flow.
  - **PROHIBITED**: The View MUST NOT maintain game state (e.g., `SelectedX`, `SelectedY`) or implement game logic (e.g., `HandleSwipe` target calculation).
- **Dependency Injection**: Pass dependencies via constructors.

## 4. Best Practices

1. **Context First**: Check existing files before creating new ones.
2. **Reuse**: Reuse existing helpers (`Position`, `GameBoard`).
3. **Safety**: Add null checks. Use `Try*` patterns.
4. **Comments**: 
   - Add XML documentation (`///`) for public APIs.
   - **Complex Logic**: MUST have clear explanations of "why" and "how".
   - **Very Complex Logic**: Use ASCII art or diagrams to visualize flow/state.
   - **Simple Code**: Do NOT comment trivial logic (e.g., getters/setters, simple assignments).
5. **Verification**: Ensure code compiles and runs in `ConsoleDemo`.

## 5. Git

- **Commit Messages**: Specific and imperative (e.g., "Add shuffle mechanics").
- **Atomic Commits**: Group related changes into separate commits (e.g., config files separate from feature logic). Never mix unrelated changes.

## 6. Autonomous Workflow

When the user requests a feature implementation or bug fix, you MUST follow this loop:

1.  **Plan**: Analyze requirements and define the necessary changes.
2.  **Test First/Concurrent**: Create or update Unit Tests (`Match3.Tests`) that cover the new logic.
3.  **Implement**: Write the code in `Match3.Core`.
4.  **Verify**: Run `dotnet test`.
    - **IF PASS**: Proceed to user notification.
    - **IF FAIL**: Analyze error, Fix code, Repeat step 4. **DO NOT** ask the user for help unless you are stuck after multiple attempts.
5.  **Deliver**: Present the verified solution to the user.

## 7. Documentation Maintenance

- **ARCHITECTURE.md**: You MUST check and update `ARCHITECTURE.md` whenever you:
  - Add new projects or major components.
  - Change core algorithms (e.g., matching logic, gravity).
  - Modify public interfaces (`IGameView`, `IRandom`).
- **Keep it Sync**: Documentation must reflect the *current* state of the code, not future plans.

## 8. Randomness & Determinism

- **Core Logic**: All random number generation in `Match3.Core` MUST use the `Match3.Core.IRandom` interface.
- **Prohibited**: Do NOT use `System.Random`, `Guid.NewGuid()`, or `DateTime` based randomness directly in game logic.
- **Goal**: Ensure the game state is fully deterministic and replayable given a specific seed.
- **Implementation**: Inject `IRandom` into classes that need randomness (e.g., `GameBoard`).
